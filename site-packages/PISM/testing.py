"""Utility functions used by PISM's regression tests"""

import PISM
import numpy as np
import uuid

def filename(prefix):
    return prefix + str(uuid.uuid4()) + ".nc"

def shallow_grid(Mx=3, My=5, Lx=10e3, Ly=20e3):
    "Create a shallow computational grid for testing"
    return PISM.IceGrid_Shallow(PISM.Context().ctx,
                                Lx, Ly, 0, 0, Mx, My,
                                PISM.CELL_CORNER,
                                PISM.NOT_PERIODIC)

def sample(vec, i=0, j=0):
    "Sample a PISM array"
    with PISM.vec.Access(nocomm=vec):
        return vec[i, j]

def check(vec, value):
    "Check if values of vec are almost equal to value."
    np.testing.assert_almost_equal(sample(vec), value)

def check_difference(A, B, value):
    "Check if the difference between A and B is almost equal to value."
    np.testing.assert_almost_equal(sample(A) - sample(B), value)

def check_ratio(A, B, value):
    "Check if the ratio of A and B is almost equal to value."
    b = sample(B)
    if b != 0:
        np.testing.assert_almost_equal(sample(A) / b, value)
    else:
        np.testing.assert_almost_equal(sample(A), 0.0)

def create_scalar_forcing(file_name, variable_name, units, values, times, time_bounds=None, time_name=None):
    "Create a dummy scalar forcing file (delta_T, etc)."

    ctx = PISM.Context()

    if time_name is None:
        time_name = ctx.config.get_string("time.dimension_name")

    bounds_name = time_name + "_bounds"

    if time_bounds is not None and times is None:
        # override times
        times = []
        for k in range(len(values)):
            times.append(0.5 * (time_bounds[2 * k + 0] +
                                time_bounds[2 * k + 1]))

    try:
        output = PISM.File(ctx.com, file_name, PISM.PISM_NETCDF3, PISM.PISM_READWRITE)
    except:
        output = PISM.File(ctx.com, file_name, PISM.PISM_NETCDF3, PISM.PISM_READWRITE_CLOBBER)

    output.define_dimension(time_name, len(times))

    output.define_variable(time_name, PISM.PISM_DOUBLE, [time_name])
    output.write_attribute(time_name, "long_name", "time")
    output.write_attribute(time_name, "axis", "T")
    output.write_attribute(time_name, "units", ctx.time.units_string())
    output.write_attribute(time_name, "calendar", ctx.config.get_string("time.calendar"))

    output.define_variable(variable_name, PISM.PISM_DOUBLE, [time_name])
    output.write_attribute(variable_name, "units", units)

    if time_bounds is not None:
        output.write_attribute(time_name, "bounds", bounds_name)

        output.define_dimension("bnds", 2)
        output.define_variable(bounds_name, PISM.PISM_DOUBLE, [time_name, "bnds"])

        output.write_variable(bounds_name, [0, 0], [len(times), 2],
                              np.array(time_bounds, dtype=np.float64).data)

    output.write_variable(time_name, [0], [len(times)],
                          np.array(times, dtype=np.float64).data)

    output.write_variable(variable_name, [0], [len(values)],
                          np.array(values, dtype=np.float64).data)

    output.close()

def create_forcing(grid, file_name, variable_name, units, values,
                   time_units=None, times=None, time_bounds=None):
    "Create a dummy 2D forcing without spatial variability"

    if times is None and time_bounds is None:
        raise ValueError("both times and time_bounds are None")

    ctx = grid.ctx()
    config = grid.ctx().config()

    time_name = config.get_string("time.dimension_name")
    time_bounds_name = time_name + "_bounds"

    if time_units is None:
        time_units = "seconds since 1-1-1"

    v = PISM.IceModelVec2S(grid, variable_name, PISM.WITHOUT_GHOSTS)
    v.metadata().set_string("units", units)

    output = PISM.util.prepare_output(file_name, append_time=False)
    output.write_attribute(time_name, "units", time_units)

    if time_bounds is not None:
        output.write_attribute(time_name, "bounds", time_bounds_name)

        bounds = PISM.VariableMetadata(time_bounds_name, ctx.unit_system(), 0)
        output.define_dimension("nv", 2)
        output.define_variable(time_bounds_name, PISM.PISM_DOUBLE, [time_name, "nv"])

        assert len(values) + 1 == len(time_bounds)
        for k in range(len(values)):
            if times is not None:
                PISM.append_time(output, "time", times[k])
            else:
                PISM.append_time(output, "time", time_bounds[k + 1])

            PISM.write_time_bounds(output, bounds, k, (time_bounds[k], time_bounds[k + 1]))

            v.set(values[k])
            v.write(output)
    else:
        for k in range(len(values)):
            PISM.append_time(output, "time", times[k])
            v.set(values[k])
            v.write(output)

    output.close()
